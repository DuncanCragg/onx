diff --git a/components/esp_driver_i2c/i2c_master.c b/components/esp_driver_i2c/i2c_master.c
index 562e6788a3..3ef7a2ae5a 100644
--- a/components/esp_driver_i2c/i2c_master.c
+++ b/components/esp_driver_i2c/i2c_master.c
@@ -16,6 +16,7 @@
 // Set the maximum log level for this source file
 #define LOG_LOCAL_LEVEL ESP_LOG_DEBUG
 #endif
+#include <esp_rom_sys.h>
 #include "esp_log.h"
 #include "esp_intr_alloc.h"
 #include "freertos/FreeRTOS.h"
@@ -530,6 +531,8 @@ static void s_i2c_send_commands(i2c_master_bus_handle_t i2c_master, TickType_t t
     }
     i2c_hal_master_trans_start(hal);
 
+    esp_rom_delay_us(333); // 288us is abs min Magic Delay
+
     // For blocking implementation, we must wait event interrupt to update the status.
     // Otherwise, update status to timeout.
     i2c_master_event_t event;
diff --git a/components/esp_driver_usb_serial_jtag/src/usb_serial_jtag.c b/components/esp_driver_usb_serial_jtag/src/usb_serial_jtag.c
index 631829de9e..55625bc957 100644
--- a/components/esp_driver_usb_serial_jtag/src/usb_serial_jtag.c
+++ b/components/esp_driver_usb_serial_jtag/src/usb_serial_jtag.c
@@ -147,6 +147,11 @@ static void usb_serial_jtag_isr_handler_default(void *arg)
         // Read RX FIFO and send available data to ringbuffer.
         uint8_t buf[USB_SER_JTAG_RX_MAX_SIZE];
         uint32_t rx_fifo_len = usb_serial_jtag_ll_read_rxfifo(buf, USB_SER_JTAG_RX_MAX_SIZE);
+
+        extern void usb_serial_jtag_char_recvd_cb(uint8_t char_recvd);
+        if(rx_fifo_len) usb_serial_jtag_char_recvd_cb(*buf);
+;       return;
+
         xRingbufferSendFromISR(p_usb_serial_jtag_obj->rx_ring_buf, buf, rx_fifo_len, &xTaskWoken);
 
         if (p_usb_serial_jtag_obj->usj_select_notif_callback) {
diff --git a/components/esp_lcd/dsi/esp_lcd_mipi_dsi_bus.c b/components/esp_lcd/dsi/esp_lcd_mipi_dsi_bus.c
index 33177a22e0..19b6701a97 100644
--- a/components/esp_lcd/dsi/esp_lcd_mipi_dsi_bus.c
+++ b/components/esp_lcd/dsi/esp_lcd_mipi_dsi_bus.c
@@ -5,6 +5,7 @@
  */
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
+#include <esp_rom_sys.h>
 #include "soc/soc_caps.h"
 #include "esp_check.h"
 #include "esp_lcd_mipi_dsi.h"
@@ -91,10 +92,10 @@ esp_err_t esp_lcd_new_dsi_bus(const esp_lcd_dsi_bus_config_t *bus_config, esp_lc
 
     // wait for PHY initialization done
     while (!mipi_dsi_phy_ll_is_pll_locked(hal->host)) {
-        vTaskDelay(pdMS_TO_TICKS(1));
+        esp_rom_delay_us(1000);
     }
     while (!mipi_dsi_phy_ll_are_lanes_stopped(hal->host, num_data_lanes)) {
-        vTaskDelay(pdMS_TO_TICKS(1));
+        esp_rom_delay_us(1000);
     }
 
     // initialize the DSI operation mode: command mode
diff --git a/components/freertos/FreeRTOS-Kernel/portable/riscv/portasm.S b/components/freertos/FreeRTOS-Kernel/portable/riscv/portasm.S
index 1bccf990c6..039857bf63 100644
--- a/components/freertos/FreeRTOS-Kernel/portable/riscv/portasm.S
+++ b/components/freertos/FreeRTOS-Kernel/portable/riscv/portasm.S
@@ -480,9 +480,18 @@ rtos_int_enter:
     li      s2, 0
 #endif /* SOC_CPU_COPROC_NUM > 0 */
 
+    /* Increment the ISR nesting count */
+    la      a0, port_uxInterruptNesting     /* a0 = &port_uxInterruptNesting */
 #if ( configNUM_CORES > 1 )
     csrr    s0, mhartid                     /* s0 = coreID */
     slli    s0, s0, 2                       /* s0 = coreID * 4 */
+    add     a0, a0, s0                      /* a0 = &port_uxInterruptNesting[coreID] // s0 contains coreID * 4 */
+#endif /* ( configNUM_CORES > 1 ) */
+    lw      a1, 0(a0)                       /* a1 = port_uxInterruptNesting[coreID] */
+    addi    a2, a1, 1                       /* a2 = a1 + 1 */
+    sw      a2, 0(a0)                       /* port_uxInterruptNesting[coreID] = a2 */
+
+#if ( configNUM_CORES > 1 )
     la      a0, port_xSchedulerRunning      /* a0 = &port_xSchedulerRunning */
     add     a0, a0, s0                      /* a0 = &port_xSchedulerRunning[coreID] */
     lw      a0, (a0)                        /* a0 = port_xSchedulerRunning[coreID] */
@@ -492,15 +501,6 @@ rtos_int_enter:
     /* In case we jump, return value (a0) is correct */
     beqz    a0, rtos_int_enter_end          /* if (port_xSchedulerRunning[coreID] == 0) jump to rtos_int_enter_end */
 
-    /* Increment the ISR nesting count */
-    la      a0, port_uxInterruptNesting     /* a0 = &port_uxInterruptNesting */
-#if ( configNUM_CORES > 1 )
-    add     a0, a0, s0                      /* a0 = &port_uxInterruptNesting[coreID] // s0 contains coreID * 4 */
-#endif /* ( configNUM_CORES > 1 ) */
-    lw      a1, 0(a0)                       /* a1 = port_uxInterruptNesting[coreID] */
-    addi    a2, a1, 1                       /* a2 = a1 + 1 */
-    sw      a2, 0(a0)                       /* port_uxInterruptNesting[coreID] = a2 */
-
     /* If we reached here from another low-priority ISR, i.e, port_uxInterruptNesting[coreID] > 0, then skip stack pushing to TCB */
     li      a0, 0                           /* return 0 in case we are going to branch */
     bnez    a1, rtos_int_enter_end          /* if (port_uxInterruptNesting[coreID] > 0) jump to rtos_int_enter_end */
@@ -612,9 +612,22 @@ rtos_int_exit:
     mv      s8, a1
 #endif
 
+    /* Update nesting interrupts counter */
+    la      a2, port_uxInterruptNesting     /* a2 = &port_uxInterruptNesting */
 #if ( configNUM_CORES > 1 )
     csrr    s7, mhartid                     /* s7 = coreID */
     slli    s7, s7, 2                       /* s7 = s7 * 4 */
+    add     a2, a2, s7                      /* a2 = &port_uxInterruptNesting[coreID] */
+#endif /* ( configNUM_CORES > 1 ) */
+    lw      a0, 0(a2)                       /* a0 = port_uxInterruptNesting[coreID] */
+    /* Already zero, protect against underflow */
+    beqz    a0, skip_decrement  /* if (port_uxInterruptNesting[coreID] == 0) jump */
+    addi    a0, a0, -1                      /* a0 = a0 - 1 */
+    sw      a0, 0(a2)                       /* port_uxInterruptNesting[coreID] = a0 */
+skip_decrement:
+    bnez    a0, rtos_int_exit_end           /* if (port_uxInterruptNesting[coreID] != 0) jump to end */
+
+#if ( configNUM_CORES > 1 )
     la      a0, port_xSchedulerRunning      /* a0 = &port_xSchedulerRunning */
     add     a0, a0, s7                      /* a0 = &port_xSchedulerRunning[coreID] */
     lw      a0, (a0)                        /* a0 = port_xSchedulerRunning[coreID] */
@@ -623,21 +636,7 @@ rtos_int_exit:
 #endif /* ( configNUM_CORES > 1 ) */
     beqz    a0, rtos_int_exit_end           /* if (port_uxSchedulerRunning == 0) jump to rtos_int_exit_end */
 
-    /* Update nesting interrupts counter */
-    la      a2, port_uxInterruptNesting     /* a2 = &port_uxInterruptNesting */
-#if ( configNUM_CORES > 1 )
-    add     a2, a2, s7                      /* a2 = &port_uxInterruptNesting[coreID] // s7 already contains coreID * 4 */
-#endif /* ( configNUM_CORES > 1 ) */
-    lw      a0, 0(a2)                       /* a0 = port_uxInterruptNesting[coreID] */
-
-    /* Already zero, protect against underflow */
-    beqz    a0, isr_skip_decrement          /* if (port_uxInterruptNesting[coreID] == 0) jump to isr_skip_decrement */
-    addi    a0, a0, -1                      /* a0 = a0 - 1 */
-    sw      a0, 0(a2)                       /* port_uxInterruptNesting[coreID] = a0 */
-    /* May still have interrupts pending, skip section below and exit */
-    bnez    a0, rtos_int_exit_end
-
-isr_skip_decrement:
+    /* now no more irq nesting and the scheduler is running */
 
 #if ( SOC_CPU_COPROC_NUM > 0 )
     /* Keep the current TCB in a0 */
